{"version":3,"file":"js/1441-97b39ded08567842d94b.chunk.js","mappings":"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","sources":["webpack://decidim-sb-app/./node_modules/@graphiql/react/dist/Range.es.js","webpack://decidim-sb-app/./node_modules/@graphiql/react/dist/hint.es.js","webpack://decidim-sb-app/./node_modules/@graphiql/react/dist/onlineParser.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whiteSpaces = match[0];\n        let pos = 0;\n        while (whiteSpaces.length > pos) {\n          if (whiteSpaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat } from \"./index.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\n__name(getDefinitionState, \"getDefinitionState\");\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\n__name(getFieldDef, \"getFieldDef\");\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state === null || state === void 0 ? void 0 : state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n__name(objectValues, \"objectValues\");\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = /* @__PURE__ */ __name((op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n}, \"collectFragmentDefs\");\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\n__name(getAutocompleteSuggestions, \"getAutocompleteSuggestions\");\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = /* @__PURE__ */ __name((field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n}, \"getInsertText\");\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\n__name(getSuggestionsForFieldNames, \"getSuggestionsForFieldNames\");\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\n__name(getSuggestionsForInputValues, \"getSuggestionsForInputValues\");\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeparator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\n__name(getSuggestionsForImplements, \"getSuggestionsForImplements\");\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n__name(getSuggestionsForFragmentTypeConditions, \"getSuggestionsForFragmentTypeConditions\");\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n__name(getSuggestionsForFragmentSpread, \"getSuggestionsForFragmentSpread\");\nconst getParentDefinition = /* @__PURE__ */ __name((state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}, \"getParentDefinition\");\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\n__name(getVariableCompletions, \"getVariableCompletions\");\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n__name(getFragmentDefinitions, \"getFragmentDefinitions\");\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n__name(getSuggestionsForVariableDefinition, \"getSuggestionsForVariableDefinition\");\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  var _a;\n  if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\n__name(getSuggestionsForDirective, \"getSuggestionsForDirective\");\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n__name(getTokenAtPosition, \"getTokenAtPosition\");\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\n__name(runOnlineParser, \"runOnlineParser\");\nfunction canUseDirective(state, directive) {\n  var _a;\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\n__name(canUseDirective, \"canUseDirective\");\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    var _a;\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n__name(getTypeInfo, \"getTypeInfo\");\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if ((results === null || results === void 0 ? void 0 : results.list) && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  var _a;\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  var _a;\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeparator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"names":["__defProp","Object","defineProperty","__name","target","value","configurable","CharacterStream","constructor","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whiteSpaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","setStart","Position","setEnd","lessThanOrEqualTo","setLine","setCharacter","getDefinitionState","tokenState","definitionState","forEachState","state","kind","getFieldDef","schema","type","fieldName","S","name","getQueryType","T","getFields","stack","fn","reverseStateStack","push","prevState","i","objectValues","object","keys","len","values","hintList","list","filterAndSortList","normalizeText","string","text","filterNonEmpty","entry","isDeprecated","map","proximity","getProximity","label","pair","sort","a","b","array","predicate","filtered","filter","toLowerCase","replace","suggestion","lexicalDistance","indexOf","j","d","aLength","bLength","cost","Math","min","SuggestionCommand","command","title","collectFragmentDefs","op","externalFragments","FragmentDefinition","def","_a","getAutocompleteSuggestions","queryText","cursor","contextToken","fragmentDefs","options","opts","assign","getTokenAtPosition","step","typeInfo","getTypeInfo","R","DOCUMENT","C","Function","Constructor","IMPLEMENTS","NAMED_TYPE","getSuggestionsForImplements","SELECTION_SET","FIELD","ALIASED_FIELD","getSuggestionsForFieldNames","ARGUMENTS","ARGUMENT","argDefs","argDef","_a2","insertText","detail","String","documentation","description","Variable","OBJECT_VALUE","OBJECT_FIELD","objectFieldDefs","objectFields","completionKind","Value","Field","field","ENUM_VALUE","LIST_VALUE","getSuggestionsForInputValues","VARIABLE","namedInputType","inputType","getVariableCompletions","v","TYPE_CONDITION","getSuggestionsForFragmentTypeConditions","FRAGMENT_SPREAD","getSuggestionsForFragmentSpread","isArray","VARIABLE_DEFINITION","LIST_TYPE","NON_NULL_TYPE","getSuggestionsForVariableDefinition","DIRECTIVE","getSuggestionsForDirective","insertSuffix","getInsertText","ofType","parentType","fields","index","sortText","deprecated","Boolean","deprecationReason","insertTextFormat","I","Snippet","queryVariables","getValues","EnumMember","concat","documentText","needsSeparator","schemaInterfaces","getTypeMap","schemaInterfaceNames","inlineInterfaces","Set","runOnlineParser","_","_b","_c","_d","_e","INTERFACE_DEF","includes","add","interfaceDef","getInterfaces","find","getType","interfaceConfig","toConfig","interfaces","objectTypeDef","objectTypeConfig","currentTypeToExtend","siblingInterfaceNames","result","Interface","_kind","possibleTypes","abstractType","possibleObjTypes","getPossibleTypes","possibleIfaceMap","create","forEach","iface","namedType","typeMap","defState","fragments","getFragmentDefinitions","frag","typeCondition","FRAGMENT_DEFINITION","getParentDefinition","_f","_g","_h","_j","_k","variableType","variableName","definitions","parentDefinition","TYPE","toString","NAME","selectionSet","selections","getDirectives","directive","canUseDirective","styleAtCursor","stateAtCursor","stringAtCursor","stream","style","callback","lines","split","parser","o","startState","locations","QUERY","MUTATION","SUBSCRIPTION","INLINE_FRAGMENT","SCHEMA_DEF","SCHEMA","SCALAR_DEF","SCALAR","OBJECT_TYPE_DEF","OBJECT","FIELD_DEF","FIELD_DEFINITION","INTERFACE","UNION_DEF","UNION","ENUM_DEF","ENUM","INPUT_DEF","INPUT_OBJECT","INPUT_VALUE_DEF","ARGUMENTS_DEF","ARGUMENT_DEFINITION","INPUT_FIELD_DEFINITION","directiveDef","enumValue","fieldDef","getMutationType","getSubscriptionType","getDirective","args","enumType","val","nullableType","objectType","objectField","registerHelper","editor","cur","getCursor","getTokenAt","tokenStart","P","results","getValue","item","from","ch","to","Pos","signal","onlineParser","eatWhitespace","lexRules","L","parseRules","editorConfig","initialState","level","rule","pushRule","getToken","inBlockstring","popRule","needsAdvance","advanceRule","tabSize","indentLevel","floor","lex","SpecialParseRules","backupState","levels","expected","separator","ofRule","call","update","unsuccessful","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","kinds"],"sourceRoot":""}